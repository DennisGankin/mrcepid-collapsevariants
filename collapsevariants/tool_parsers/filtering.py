from pathlib import Path
from typing import Dict

import pandas as pd

from collapsevariants.ingest_data import BGENIndex
from collapsevariants.tool_parsers.bolt_parser import BOLTParser
from collapsevariants.tool_parsers.regenie_parser import parse_filters_REGENIE
from collapsevariants.tool_parsers.saige_parser import parse_filters_SAIGE
from collapsevariants.tool_parsers.staar_parser import STAARParser, STAARMergingException

def generate_masks(genes: Dict[str, pd.DataFrame], bgen_index: Dict[str, BGENIndex],
                   output_prefix: str) -> pd.DataFrame:
    """Helper method for running separate BGENs through the collapsing process (returns function as a future).

    This method just works through all possible formatting methods (for BOLT, SAIGE, and STAAR) to generate a final
    suite of files for input to the runassociationtesting burden testing suite. These files are:

    1. A BOLT-ready .bgen and .sample file
    2. A SAIGE/REGENIE-ready .bcf, bcf.csi (index), and groupFile
    3. A STAAR-ready sparse matrix saved in .rds format and a .tsv containing variant information

    :return: A pandas.DataFrame containing per-sample and per-ENST totals for log reporting purposes.
    """

    # Here we are then taking the file generated by run_filtering() and generating various text/plink/vcf files
    # to generate a merged set of variants we want to test across all VCF files and that will be used as part of
    # mrcepid-mergecollapsevariants.
    #
    # JUST TO BE CLEAR – the names of the functions here are not THAT important (e.g., files generated in the
    # function parse_filters_BOLT() will be used for other tools/workflows). It was just for me (Eugene Gardner)
    # to keep things organised when writing this code

    bolt_parser = BOLTParser(genes, bgen_index, output_prefix)

    genes, snp_gene_map = parse_filters_SAIGE(self._output_prefix, chromosome, self._cmd_exec)

    poss_indv, samples = parse_filters_BOLT(self._output_prefix, chromosome, genes, snp_gene_map, self._cmd_exec)

    sample_table = check_vcf_stats(poss_indv, samples)

    # STAAR fails sometimes for unknown reasons, so try it twice if it fails before throwing the entire process
    try:
        STAARParser(self._output_prefix, chromosome, self._cmd_exec).parse_filters_STAAR()
    except STAARMergingException:
        self._logger.warning(f'STAAR chr {chromosome} failed to merge, trying again...')
        STAARParser(self._output_prefix, chromosome, self._cmd_exec).parse_filters_STAAR()

    parse_filters_REGENIE(self._output_prefix, chromosome)

    # Purge files that we no longer need:
    Path(f'{self._output_prefix}.{chromosome}.parsed.txt').unlink()

    self._logger.info(f'Finished bgen: chr{chromosome}.filtered.bgen')
    return sample_table


def check_vcf_stats(poss_indv: List[str], genotypes: Dict[str, Dict[str, int]]) -> pd.DataFrame:
    """Get information relating to included variants in bcf format files (per-variant)

    This method calculates per-sample and per-gene totals for this chromosome

    :param poss_indv: Identical to return 1 from parse_filters_BOLT – a List of samples that were found
    :param genotypes: Identical to return 2 from parse_filters_BOLT – a Dictionary with keys of sample IDs and values of
        a dictionary of ENST / Genotype pairs for that given individual
    :return: A pandas.DataFrame containing per-sample and per-gene totals for this chromosome
    """

    sample_table = pd.DataFrame(data={'sample_id': poss_indv})
    geno_dict = {'sample_id': [], 'ac': [], 'ac_gene': []}
    for sample in genotypes:
        samp_total = 0
        gene_total = 0
        for gene in genotypes[sample]:
            samp_total += genotypes[sample][gene]
            gene_total += 1
        geno_dict['sample_id'].append(sample)
        geno_dict['ac'].append(samp_total)
        geno_dict['ac_gene'].append(gene_total)

    found_genotypes = pd.DataFrame.from_dict(geno_dict)
    sample_table = pd.merge(sample_table, found_genotypes, on='sample_id', how="left")
    sample_table['ac'] = np.where(sample_table['ac'] >= 1, sample_table['ac'], 0)
    sample_table['ac_gene'] = np.where(sample_table['ac_gene'] >= 1, sample_table['ac_gene'], 0)

    return sample_table
